#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <sys/wait.h>
#include <unistd.h>

#define MAX_LINE_LENGTH 80

void fcfs();
void rr();

#define PROC_NEW	0
#define PROC_STOPPED	1
#define PROC_RUNNING	2
#define PROC_EXITED	3
#define NUM_PROCESSORS 4  // Number of processors

typedef struct proc_desc {
	struct proc_desc *next;
	char name[80];
	int pid;
	int status;
	double t_submission, t_start, t_end;
} proc_t;

int processors[NUM_PROCESSORS];

struct single_queue {
	proc_t	*first;
	proc_t	*last;
	long members;
};

struct single_queue global_q;

#define proc_queue_empty(q) ((q)->first==NULL)

void proc_queue_init (register struct single_queue * q)
{
	q->first = q->last = NULL;
	q->members = 0;
}

void proc_to_rq (register proc_t *proc)
{
	if (proc_queue_empty (&global_q))
		global_q.last = proc;
	proc->next = global_q.first;
	global_q.first = proc;
}

void proc_to_rq_end (register proc_t *proc)
{
	if (proc_queue_empty (&global_q))
		global_q.first = global_q.last = proc;
	else {
		global_q.last->next = proc;
		global_q.last = proc;
		proc->next = NULL;
	}
}

proc_t *proc_rq_dequeue ()
{
	register proc_t *proc;

	proc = global_q.first;
	if (proc==NULL) return NULL;

	proc = global_q.first;
	if (proc!=NULL) {
		global_q.first = proc->next;
		proc->next = NULL;
	}

	return proc;
}


void print_queue()
{
	proc_t *proc;

	proc = global_q.first;
	while (proc != NULL) {
		printf("proc: [name:%s pid:%d]\n", 
			proc->name, proc->pid);
		proc = proc->next;
	}
}

double proc_gettime()
{
	struct timeval tv;
	gettimeofday(&tv, 0);
	return (double) (tv.tv_sec+tv.tv_usec/1000000.0);
}

#define FCFS	0
#define RR		1

int policy = FCFS;
int quantum = 100;	/* ms */
proc_t *running_processes[NUM_PROCESSORS];
int pid_to_processor[NUM_PROCESSORS]; // Maps pids to processor indices
double global_t;

void err_exit(char *msg)
{
	printf("Error: %s\n", msg);
	exit(1);
}

int main(int argc,char **argv)
{
	FILE *input;
	char exec[80];
	int c;
	proc_t *proc;

	if (argc == 1) {
		err_exit("invalid usage");
	} else if (argc == 2) {
		input = fopen(argv[1],"r");
		if (input == NULL) err_exit("invalid input file name");
	} else if (argc > 2) {
		if (!strcmp(argv[1],"FCFS")) {
			policy = FCFS;
			input = fopen(argv[2],"r");
			if (input == NULL) err_exit("invalid input file name");
		} else if (!strcmp(argv[1],"RR")) {
			policy = RR;
			quantum = atoi(argv[2]);
			input = fopen(argv[3],"r");
			if (input == NULL) err_exit("invalid input file name");
		} else {
			err_exit("invalid usage");
		}
	}

	/* Read input file */
	while ((c=fscanf(input, "%s", exec))!=EOF) {
		// printf("fscanf returned %d\n", c);
		// printf("exec = %s\n", exec);

		proc = malloc(sizeof(proc_t));
		proc->next = NULL;
		strcpy(proc->name, exec);
		proc->pid = -1;
		proc->status = PROC_NEW;
		proc->t_submission = proc_gettime();
		proc_to_rq_end(proc);
	}

	//print_queue(&global_q);

  	global_t = proc_gettime();
	switch (policy) {
		case FCFS:
			fcfs();
			break;

		case RR:
			rr();
			break;

		default:
			err_exit("Unimplemented policy");
			break;
	}

	printf("WORKLOAD TIME: %.2lf secs\n", proc_gettime()-global_t);
	printf("scheduler exits\n");
	return 0;
}


void fcfs()
{
	proc_t *proc;
	int pid;
	int status;

	while ((proc=proc_rq_dequeue()) != NULL) {
		// printf("Dequeued process with name %s\n", proc->name);
		if (proc->status == PROC_NEW) {
			proc->t_start = proc_gettime();
			pid = fork();
			if (pid == -1) {
				err_exit("fork failed!");
			}
			if (pid == 0) {
				printf("executing %s\n", proc->name);
				execl(proc->name, proc->name, NULL);
			} else {
				proc->pid = pid;
				proc->status = PROC_RUNNING;
				pid = waitpid(proc->pid, &status, 0);
				proc->status = PROC_EXITED;
				if (pid < 0) err_exit("waitpid failed");
				proc->t_end = proc_gettime();
				printf("PID %d - CMD: %s\n", pid, proc->name);
				printf("\tElapsed time = %.2lf secs\n", proc->t_end-proc->t_submission);
				printf("\tExecution time = %.2lf secs\n", proc->t_end-proc->t_start);
				printf("\tWorkload time = %.2lf secs\n", proc->t_end-global_t);
			}
		}
	}
}


void sigchld_handler(int signo, siginfo_t *info, void *context) {
    pid_t exited_pid = info->si_pid; // PID of the child process that exited
    int exit_status = info->si_status; // Exit status from child
    int signal_code = info->si_code; // Reason for the signal (e.g., CLD_EXITED)

    printf("SIGCHLD received for PID %d\n", exited_pid);

    // Find the processor index for the exited process
    int processor_index = -1;
    for (int i = 0; i < NUM_PROCESSORS; i++) {
        if (running_processes[i] != NULL && running_processes[i]->pid == exited_pid) {
            processor_index = i;
            break;
        }
    }

    if (processor_index == -1) {
        printf("Warning: Could not find processor for PID %d\n", exited_pid);
        return;
    }

    proc_t *proc = running_processes[processor_index];
    if (proc) {
        proc->status = PROC_EXITED;
        proc->t_end = proc_gettime();
        printf("Processor %d - PID %d - CMD: %s\n", processor_index, proc->pid, proc->name);
        printf("\tElapsed time = %.2lf secs\n", proc->t_end - proc->t_submission);
        printf("\tExecution time = %.2lf secs\n", proc->t_end - proc->t_start);
        printf("\tWorkload time = %.2lf secs\n", proc->t_end - global_t);

        running_processes[processor_index] = NULL; // Free the processor slot
    } else {
        printf("Warning: No running process found for processor %d\n", processor_index);
    }
}

void rr() {
    struct sigaction sig_act;
    proc_t *proc;
    int pid;
    struct timespec req, rem;

    // Quantum setup for sleep
    req.tv_sec = quantum / 1000;
    req.tv_nsec = (quantum % 1000) * 1000000;

    // Signal handler setup
    sigemptyset(&sig_act.sa_mask);
    sig_act.sa_flags = SA_SIGINFO | SA_NOCLDSTOP;
    sig_act.sa_sigaction = sigchld_handler;
    sigaction(SIGCHLD, &sig_act, NULL);

    // Initialize running processes and pid-to-processor mapping
    for (int i = 0; i < NUM_PROCESSORS; i++) {
        running_processes[i] = NULL;
    }

    while (1) {
        // Distribute processes to available processors
        for (int i = 0; i < NUM_PROCESSORS; i++) {
            if (running_processes[i] == NULL || running_processes[i]->status == PROC_EXITED) {
                proc = proc_rq_dequeue();
                if (proc == NULL) continue;  // No more processes in the queue

                running_processes[i] = proc;
                proc->status = PROC_RUNNING;

                pid = fork();
                if (pid == -1) {
                    err_exit("fork failed!");
                }
                if (pid == 0) {
                    // Child process
                    printf("Processor %d executing %s\n", i, proc->name);
                    execl(proc->name, proc->name, NULL);
                } else {
                    // Parent process
                    proc->pid = pid;
                    proc->t_start = proc_gettime();
                }
            }
        }

        // Sleep for the quantum
        nanosleep(&req, &rem);

        // Check the status of each processor's process
        for (int i = 0; i < NUM_PROCESSORS; i++) {
            if (running_processes[i] != NULL && running_processes[i]->status == PROC_RUNNING) {
                // Check if the process has exited
                int status;
                pid_t result = waitpid(running_processes[i]->pid, &status, WNOHANG);
                if (result > 0) {
                    // Process has exited
                    running_processes[i]->status = PROC_EXITED;
                } else {
                    // Process is still running, stop it and requeue
                    kill(running_processes[i]->pid, SIGSTOP);
                    running_processes[i]->status = PROC_STOPPED;
                    proc_to_rq_end(running_processes[i]);
                    running_processes[i] = NULL;
                }
            }
        }

        // Check if all processes are done
        int all_done = 1;
        for (int i = 0; i < NUM_PROCESSORS; i++) {
            if (running_processes[i] != NULL) {
                all_done = 0;
                break;
            }
        }
        if (all_done && proc_queue_empty(&global_q)) {
            break;
        }
    }
}
